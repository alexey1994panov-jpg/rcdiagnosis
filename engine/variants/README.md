# Алгоритмы ЛЗ/ЛС для 1П (станция Visochino)

Документ фиксирует **эталонную** логику всех вариантов ЛЗ и ЛС, а также их взаимодействие с T_PK и движком `simulate_1p`. Любые изменения алгоритмов, не описанные здесь, являются ошибкой и требуют пересогласования и обновления тестов.

## Общие правила для всех детекторов

- У каждого детектора есть внутренний флаг `self.active`, который:
  - устанавливается в `True` при первом `opened=True`;
  - сбрасывается в `reset()` после `closed=True`.
- `reset()` обязан вернуть детектор в исходную фазу (`phase="idle"`/эквивалент) и обнулить все `dur_*`, `active` и вспомогательные флаги.
- Внутри `update(step, dt_interval)`:
  - нельзя делить время или гонять внутренние циклы по dt;
  - выдержки реализуются только суммированием `dur += dt_interval`.
- Достоверность смежных:
  - до открытия ДС детектор обязан учитывать `prev_control_ok` / `next_control_ok`;
  - после открытия (`self.active=True`) потеря достоверности смежных **не сбрасывает** ДС, завершение идёт только по Curr и T_KON/T_KON_LS.
- T_PK реализован снаружи, через `update_adjacency` и поля `prev_control_ok` / `next_control_ok` в `step.modes`.

## Логика T_PK (Tпк) и смежных РЦ

Реализация — `engine/adjacency_1p.py`.

- Состояние стрелок:
  - `Sw10` задаёт ветку на предыдущее РЦ (Prev);
  - `Sw1`+`Sw5` задают ветку на следующее РЦ (Next).
- При допустимом положении стрелок:
  - вычисляются `current_prev` / `current_next` по `station.prev_candidates[0]` / `station.next_candidates[0]`;
  - значения запоминаются в `state.latched_prev` / `state.latched_next`;
  - таймеры `time_since_prev_lost` / `time_since_next_lost` обнуляются.
- При потере контроля стрелок:
  - если латч был, таймеры увеличиваются на `dt_interval`;
  - пока `time_since_*_lost <= T_PK`, используются latched значения и `*_control_ok=True`;
  - после `time_since_*_lost > T_PK` смежные считаются недостоверными (`current_prev=""`, `prev_control_ok=False`, аналогично для Next).
- `simulate_1p` на каждом шаге:
  - вызывает `update_adjacency`;
  - записывает `prev_control_ok` / `next_control_ok` в `step.modes` (через присваивание; значения из сценария не должны перезаписывать результат adjacency).

## Варианты ЛЗ

### ЛЗ вариант 1 (`variant1_1p.py`)

- Фазы (упрощённо):
  - S0101: базовая занятость Curr, смежные в допустимых комбинациях;
  - хвост: Curr=1 и смежные в требуемой конфигурации не менее T_LZ01;
  - завершение ДС: Curr=0 не менее T_KON.
- Контроль смежных:
  - до открытия — требуются достоверные обе смежные (`prev_control_ok=True`, `next_control_ok=True`);
  - после открытия — завершение только по Curr/T_KON.
- Эталонный тест:
  - идеальный сценарий по шагам, открытие/закрытие в согласованных секундах;
  - зафиксирован в регрессионных тестах (см. `test_big_scenario_1p.py` и отдельные сценарии для v1).

### ЛЗ вариант 2 (`variant2_1p.py`)

- Две ветки: «предыдущая занята» и «следующая занята».
- Каждая ветка:
  - S0102: занятость Curr+одна смежная;
  - S0202: вторая фаза занятости;
  - хвост: Curr и смежные в конфигурации 0‑1‑0 / 1‑0‑1 (в зависимости от ветки);
  - завершение: Curr=0 не менее T_KON.
- Контроль смежных:
  - старт и продолжение только при `prev_control_ok`/`next_control_ok` по соответствующей ветке;
  - после открытия — только Curr/T_KON.
- Вариант 2 зафиксирован как эталон; алгоритм и флаги (`llz_v2`, `llz_v2_open`, `llz_v2_closed`) менять нельзя.

### ЛЗ вариант 3 (`variant3_1p.py`)

- Сценарий «среднего» варианта (по ТЗ).
- Общая схема:
  - S0103: первая фаза при заданной конфигурации смежных+Curr;
  - хвост: Curr свободна, смежные в заданном состоянии, выдержка T_LZ03;
  - S0203: повторная занятость Curr, выдержка T_S0203;
  - завершение: Curr=0 по T_KON.
- Контроль смежных — аналогично v1/v2: до открытия ЛЗ3 учитываются `*_control_ok`, после открытия — только Curr и T_KON.
- Вариант 3 зафиксирован как эталон.

### ЛЗ вариант 4 (`variant4_1p.py`)

- Детектор ложной занятости **v4** фиксирует ситуацию, когда контролируемая РЦ становится занятой при закрытом входном/выходном светофоре и отсутствии контроля по одной из смежных РЦ.
- Работает по трём РЦ:
  - `prev_rc_id` — предыдущая РЦ;
  - `ctrl_rc_id` — контролируемая РЦ (Curr);
  - `next_rc_id` — следующая РЦ.
- Использует флаги смежности из `step.modes`:
  - `prev_control_ok`, `next_control_ok` формируются в `simulate_1p` через `update_adjacency` с учётом ТПК (`T_PK`);
  - внутри детектора они преобразуются в:
    - `prev_nc = not prev_control_ok`;
    - `next_nc = not next_control_ok`.

#### Ветка 4.1 — предыдущая без контроля, входной поездной

- **ДАНО** (фаза `p1_4_1`):
  - `prev_nc = True` (нет контроля предыдущей РЦ);
  - Curr свободна (`П=0`);
  - Next свободна (`П=0`);
  - входной поездной светофор `prev -> ctrl` (`signal_prev_to_ctrl_id`, например ЧМ1) закрыт (`signal_is_closed`) непрерывно не менее `T_S0401`.
- **КОГДА**:
  - Curr занята (`П=1`);
  - тот же входной поездной светофор остаётся закрытым не менее `T_LZ04`.
- При выполнении условий:
  - детектор открывает ДС v4 (`opened=True`, флаг `llz_v4_open`);
  - переходит в состояние активной ЛЗ (`active=True`, флаг `llz_v4`).

#### Ветка 4.2 — следующая без контроля, выходной маневровый

- **ДАНО** (фаза `p1_4_2`):
  - Prev свободна (`П=0`);
  - Curr свободна (`П=0`);
  - `next_nc = True` (нет контроля следующей РЦ);
  - выходной маневровый светофор `ctrl -> next` (`signal_ctrl_to_next_id`, например М1) закрыт, при этом:
    - если `ctrl_to_next_is_shunting=True` — проверка через `shunting_signal_is_closed` (коды маневрового закрытия);
    - если `False` — через `signal_is_closed`;
  - выдержка ДАНО не менее `T_S0401`.
- **КОГДА**:
  - Curr занята (`П=1`);
  - тот же выходной светофор закрыт не менее `T_LZ04`.
- При выполнении условий:
  - детектор открывает ДС v4 (`llz_v4_open`) и входит в активное состояние (`llz_v4`).

#### Завершение ДС

- Пока Curr занята, ДС v4 остаётся активным, таймер завершения не идёт.
- После того как Curr стала свободной (`П=0`), детектор накапливает `dur_free_after_lz`.
- При непрерывной свободе Curr не менее `T_KON`:
  - детектор закрывает ДС (`closed=True`, флаг `llz_v4_closed`);
  - состояние полностью сбрасывается (`phase="idle"`, таймеры обнулены, `active=False`).

#### Особенности реализации

- Детектор не жёстко привязан к конкретным РЦ; `prev_rc_id`, `ctrl_rc_id`, `next_rc_id`, а также идентификаторы светофоров (`signal_prev_to_ctrl_id`, `signal_ctrl_to_next_id`) задаются снаружи при инициализации.
- Признак маневровости выходного сигнала (`ctrl_to_next_is_shunting`) позволяет использовать один и тот же детектор для:
  - входного поездного ЧМ1 и выходного поездного Ч1 (ветка 4.1 на разных контролируемых РЦ);
  - входного поездного и выходного маневрового М1 (ветка 4.2 для крайних РЦ).
- Флаги активности и событий на таймлайне:
  - активное состояние: `llz_v4`;
  - момент открытия: `llz_v4_open`;
  - момент закрытия: `llz_v4_closed`.

### ЛЗ вариант 5 (`variant5_1p.py`)

- Вариант 5 диагностирует **ложную занятость РЦ, которая должна быть без замыкания маршрута**, с возможностью учитывать или игнорировать состояния с замыканием. 
- Параметр `allow_route_lock_states` определяет, считать ли «допустимыми» состояния с замыканием (4,5 для свободной и 7,8 для занятой) или работать строго по «беззамковым» кодам 3 и 6. 

- Пороги:  
  - `TS05` — минимальная длительность свободности (ДАНО);  
  - `TLZ05` — минимальная длительность занятости (КОГДА);  
  - `TKON` — свободность для завершения ДС. 

- ДАНО (`phase="idle"`):  
  - РЦ свободна без маршрута по `_is_free_no_lock` (код 3, опционально 4–5) непрерывно ≥ `TS05` → `phase="given_done"`.  
  - Любое «несвободное» состояние до выполнения ДАНО сбрасывает `dur_free` и `dur_occ`. 

- КОГДА (`phase="given_done"`):  
  - РЦ занята без маршрута по `_is_occupied_no_lock` (код 6, опционально 7–8) непрерывно ≥ `TLZ05` → ЛЗ v5: `opened=True`, `active=True`, `phase="active"`. 
  - Если до `TLZ05` снова наступает свободность или неопределённое состояние, детектор полностью `reset()`.  

- Завершение ДС (`phase="active"`):  
  - При свободности по `_is_free_no_lock` накапливается `dur_free_after_lz`; при `dur_free_after_lz ≥ TKON` → `closed=True` и `reset()`.  
  - При занятости или неопределённом состоянии таймер завершения обнуляется, ЛЗ остаётся активной. 
- Вариант 5 строго эталонный, логика веток, пороги и взаимодействие с T_PK менять нельзя.  

### ЛЗ вариант 6 (`variant6_1p.py`)

- Вариант 6 фиксирует **длительную занятость одной РЦ без замыкания маршрута**, без учёта смежных РЦ и сигналов. 
- Применяется к любой незамкнутой РЦ; решение о том, к каким именно, принимается в `init_detectors`. 

- Пороги:  
  - `TS06` — минимальная длительность свободности (ДАНО);  
  - `TLZ06` — минимальная длительность занятости (КОГДА);  
  - `TKON` — свободность для завершения ДС. 

- ДАНО (`phase="idle"`):  
  - РЦ свободна (`rc_is_free`) подряд ≥ `TS06` → переход в `phase="given_done"`.  
  - Любое несвободное или неопределённое состояние до выполнения ДАНО обнуляет `dur_free` и `dur_occ`. 

- КОГДА (`phase="given_done"`):  
  - РЦ занята (`rc_is_occupied`) подряд ≥ `TLZ06` → ЛЗ v6: `opened=True`, `active=True`, `phase="active"`.  
  - Если до `TLZ06` РЦ снова свободна или состояние неопределено, детектор полностью `reset()`. 

- Завершение ДС (`phase="active"`):  
  - При свободности РЦ накапливается `dur_free_after_lz`; при `dur_free_after_lz ≥ TKON` → `closed=True` и `reset()`.  
  - При занятости или неопределённом состоянии таймер завершения сбрасывается, ЛЗ остаётся активной. 
- Вариант 6 строго эталонный, логика веток, пороги и взаимодействие с T_PK менять нельзя.

### ЛЗ вариант 7 (`variant7_1p.py`)

- Вариант 7 выявляет **ложную занятость** на бесстрелочной контролируемой РЦ с учётом наличия/отсутствия смежных РЦ по положению стрелок. 
- Объединяет требования старого варианта для «нет смежных РЦ» и подварианты:  
  - v7.1 — «нет предыдущей по положению стрелки»;  
  - v7.2 — «нет следующей по положению стрелки». 
- Общие временные пороги:  
  - `TS07` — ДАНО (устойчивая свободность);  
  - `TLZ07` — КОГДА (устойчивая занятость);  
  - `TKON` — завершение ДС после устойчивой свободности. 

- Входные данные и флаги:  
  - `ctrl_rc_id` — контролируемая РЦ, на которой ищется ложная занятость;  
  - `prev_rc_id` / `next_rc_id` — смежные РЦ, если они существуют;  
  - `modes["prev_control_ok"]`, `modes["next_control_ok"]` — флаги, показывающие, «видит» ли контролируемая РЦ предыдущую/следующую по текущему положению стрелок (устанавливаются в `simulate_1p.update_adjacency()`). 

- ДАНО (`_given_condition`):  
  - Общий принцип: контролируемая РЦ **свободна**, и конфигурация смежных РЦ соответствует одной из трёх ситуаций. 
  - 1) «Нет смежных РЦ» (старый v6):  
    - `ctrl_free = True`;  
    - `prev_control_ok = False`, `next_control_ok = False`.  
  - 2) v7.1 — «нет предыдущей по положению стрелки»:  
    - `ctrl_free = True`;  
    - `prev_control_ok = False`, `next_control_ok = True`;  
    - следующая РЦ существует и свободна (`next_free = True`).  
  - 3) v7.2 — «нет следующей по положению стрелки»:  
    - `ctrl_free = True`;  
    - `prev_control_ok = True`, `next_control_ok = False`;  
    - предыдущая РЦ существует и свободна (`prev_free = True`).  

- КОГДА (`_when_condition`):  
  - Общий принцип: контролируемая РЦ **занята**, и сохраняется та же конфигурация смежных РЦ, что и в ДАНО, с заменой `ctrl_free` на `ctrl_occ`. 
  - 1) «Нет смежных РЦ»:  
    - `ctrl_occ = True`;  
    - `prev_control_ok = False`, `next_control_ok = False`.  
  - 2) v7.1 — «нет предыдущей по положению стрелки»:  
    - `ctrl_occ = True`;  
    - `prev_control_ok = False`, `next_control_ok = True`;  
    - следующая РЦ по‑прежнему свободна (`next_free = True`).  
  - 3) v7.2 — «нет следующей по положению стрелки»:  
    - `ctrl_occ = True`;  
    - `prev_control_ok = True`, `next_control_ok = False`;  
    - предыдущая РЦ остаётся свободной (`prev_free = True`).  

- Фазовая логика детектора:  
  - Фазы: `"idle" → "given_done" → "active"`.  
  - В `"idle"` накапливается `dur_free`, пока `_given_condition` выполняется подряд не менее `TS07`; при нарушении ДАНО оба таймера `dur_free` и `dur_occ` сбрасываются. 
  - При достижении `TS07` фаза переключается в `"given_done"`, дальнейшие нарушения ДАНО игнорируются, анализируется только КОГДА.  
  - В `"given_done"` накапливается `dur_occ`, пока `_when_condition` выполняется подряд не менее `TLZ07`; при нарушении КОГДА вызывается `reset()` и детектор возвращается в `"idle"`.  

- Открытие и завершение ДС:  
  - При достижении `dur_occ ≥ TLZ07` в фазе `"given_done"` формируется ЛЗ7:  
    - `opened = True`, `active = True`, `phase = "active"`, `dur_free_after_lz = 0`.  
  - В фазе `"active"` детектор отслеживает только состояние контролируемой РЦ:  
    - если контролируемая РЦ свободна, накапливается `dur_free_after_lz`;  
    - при `dur_free_after_lz ≥ TKON` ЛЗ7 считается завершённой: `closed = True`, вызывается `reset()`. 
    - если РЦ снова занята, таймер завершения обнуляется, но ЛЗ остаётся активной.
- Вариант 7 строго эталонный, логика веток, пороги и взаимодействие с T_PK менять нельзя.



### ЛЗ вариант 8 (`variant8_1p.py`)

- Вариант 8 имеет три подварианта:
  - В8.1 — «предыдущая занята»;
  - В8.2 — «следующая занята»;
  - В8.3 — «средний».
- Общие пороги:
  - `T_S0108` — первая фаза;
  - `T_S0208` — вторая фаза;
  - `T_LZ08` — хвост;
  - `T_KON` — завершение ДС.
- В8.1 (prev):
  - S0108: Prev=1, Curr=1, Next=0/1 подряд `T_S0108`;
  - S0208: Curr=1, Next=1 подряд `T_S0208`;
  - хвост: Prev=0, Curr=1, Next=0 подряд `T_LZ08` → открытие ЛЗ8.
- В8.2 (next) — **эталонный сценарий ЛЗ8**:
  - фаза 1: Curr=1, Next=1 (Prev может быть 0 или 1), `*-1-1` подряд `T_S0108`;
  - фаза 2: две альтернативы:
    - 8.2.1: Prev=0, Curr=1, Next=* (`0‑1‑*`);
    - 8.2.2: Prev=*, Curr=1, Next=0 (`*‑1‑0`);
    - любая из альтернатив набирает `T_S0208`;
  - хвост: Prev=0, Curr=1, Next=0 (`0‑1‑0`) подряд `T_LZ08` → открытие ЛЗ8;
  - завершение: Curr=0 по `T_KON`.
  - Эталонный тест: ЛЗ8 открывается на 6‑й секунде сценария `test_big_scenario_1p.py`, закрывается на 13‑й.
- В8.3 (mid):
  - S0108: Prev=0, Curr=1, Next=0 (`0‑1‑0`) `T_S0108`;
  - S0208: Prev=0, Curr=1, Next=1 (`0‑1‑1`) `T_S0208`;
  - хвост: Prev=0, Curr=1, Next=0 `T_LZ08` → открытие, далее завершение по Curr/T_KON.
- Вариант 8 строго эталонный, логика веток, пороги и взаимодействие с T_PK менять нельзя.


### ЛЗ вариант 9 (`variant9_1p.py`)

- Назначение:
  - Вариант 9 реализует ЛЗ типа «пробой изолирующего стыка» для одной контролируемой РЦ `ctrl` и набора смежных РЦ `adjacent_rc_ids`.
  - Учитывает признак замыкания только на контролируемой РЦ (`station.rc_has_route_lock[ctrl_rc_id]`).
- Семантика:
  - «занята» / «свободна» — через `rc_is_occupied` / `rc_is_free`. 
  - `ctrl_locked` — логическое замыкание (`З=1`) по `rc_has_route_lock`. 
  - Для смежных замыкание не анализируется, берутся только их состояния занятости. 

- Пороговые времена:
  - `T_S0109` — выдержка исходного состояния (ДАНО). 
  - `T_LZ09` — максимальное допустимое окно по времени между занятием `ctrl` и любой смежной РЦ (модуль разности ≤ `T_LZ09`). 
  - `T_KON` (`t_kon_v9`) — время непрерывной свободности `ctrl` и всех смежных для завершения ДС. 

- Фазы и состояния:
  - `phase`:
    - `"idle"` — исходное состояние не выдержано.
    - `"ready"` — ДАНО выполнено, ждём пары занятостей в окне `T_LZ09`.
    - `"active"` — ДС сформировано. 
  - Таймеры:
    - `dur_s0` — длительность исходного состояния (ДАНО).
    - `dur_free_after_lz` — длительность свободности `ctrl + все смежные` после открытия ДС. 
  - Внутреннее время:
    - `_time` — накапливаемое «локальное время» детектора.
    - `ctrl_last_occ_time` — время первого занятия `ctrl` после ДАНО.
    - `adj_last_occ_time` — время первого занятия любой смежной после ДАНО.

- Ветка 9.1 (ctrl замкнута, `З=1`):
  - **ДАНО (фаза `"idle"`):**
    - `ctrl_free` и `ctrl_locked == True`. 
    - `adj_any_free == True` (хотя бы одна смежная свободна).
    - Условия выполняются непрерывно ≥ `T_S0109`:
      - накапливается `dur_s0`;
      - при достижении порога: `phase = "ready"`, оба маркера занятости (`ctrl_last_occ_time`, `adj_last_occ_time`) обнуляются. 
    - При разрыве условий (ctrl не свободна или нет свободной смежной) `dur_s0` сбрасывается. 
  - **КОГДА (фаза `"ready"`):**
    - При первом появлении занятости `ctrl_occ` фиксируется `ctrl_last_occ_time = _time`.
    - При первом появлении занятости любой смежной (`adj_any_occ`) фиксируется `adj_last_occ_time = _time`. 
    - Как только оба времени заданы:
      - вычисляется \(|Δt| = |ctrl\_last\_occ\_time - adj\_last\_occ\_time|\);
      - если \(|Δt| ≤ T_LZ09\):
        - открывается ЛЗ9 (`opened = True`);
        - `active = True`, `phase = "active"`;
        - `dur_free_after_lz` обнуляется. 
    - Дальнейшие изменения после формирования пары для открытия не учитываются (вариант 9 одноразово реагирует на первую пару занятостей после ДАНО). 

- Ветка 9.2 (ctrl не замкнута, `З=0`):
  - **ДАНО:**
    - `ctrl_free` и `ctrl_locked == False`. 
    - `adj_all_free == True` (все смежные свободны).
    - Аналогично ветке 3.1, выдержка ≥ `T_S0109` переводит в `phase = "ready"`. 
  - **КОГДА:**
    - Логика идентична ветке 3.1:
      - фиксируются первые занятия `ctrl` и любой смежной;
      - если интервал между ними по модулю не превышает `T_LZ09`, формируется ДС. 

- Завершение ДС:
  - Работает только при `active = True` и `phase = "active"`:
    - контролируется, что **и `ctrl`, и все смежные свободны**: `ctrl_free` и `adj_all_free`. 
    - при выполнении этих условий:
      - `dur_free_after_lz` накапливается;
      - если `dur_free_after_lz ≥ T_KON`:
        - ДС считается завершённым (`closed = True`);
        - вызывается `reset()` (сброс фаз, таймеров и временных меток). 
    - любое занятие `ctrl` или любой смежной в активной фазе:
      - сбрасывает `dur_free_after_lz` (завершение «откатывается», ДС остаётся активным). 

- Особенности и ограничения:
  - Если список смежных пуст (`adjacent_rc_ids` пустой), `_adj_states` возвращает `(all_free=True, any_free=True, any_occ=False)`, фактически отключая смысл варианта 9 для такой конфигурации. 
  - Замыкание анализируется только на `ctrl`; смежные считаются обычными РЦ без признака замыкания. 
  - Детектор не сам включает/отключает вариант 9: флаг `enable_v9` учитывается снаружи, при решении, вызывать ли `update`. 
- Вариант 9 строго эталонный, логика веток, пороги и взаимодействие с T_PK менять нельзя.

### ЛЗ вариант 10 (`variant10_1p.py`)

- Работает по трём РЦ:
  - `prev` — предыдущая РЦ (`10-12SP` или `1-7SP`, в зависимости от смежности). 
  - `curr` — контролируемая РЦ (`1P`).
  - `next` — следующая РЦ (`1-7SP` или `10-12SP`). 
- Использует один маршрутный светофор между `curr` и `next`:
  - `Ч1` при движении `1P → 1-7SP` (ветка 10.1). 
  - `НМ1` при движении `1P → 10-12SP` (ветка 10.2). 
- Направление (`to_next` / `to_prev`) фиксируется в `self.direction` по конфигурации занятости (`prev/next`) и далее используется для выбора светофора на всех фазах, включая КОГДА. 

- Пороговые времена:
  - `TS0110` — фаза 01 (общая для веток 10.1/10.2). 
  - `TS0210` — фаза 02 (различает ветки 10.1 и 10.2). 
  - `TS0310` — фаза 03. 
  - `TLZ10` — фаза КОГДА (LZ10). 
  - `TKON` — завершение ДС (освобождение `curr`). 

- Фаза 01 (общая, `"idle" → "p1done"`):
  - Конфигурация по РЦ: `prev_free`, `curr_occ`, `next_free` (`0‑1‑0`). 
  - Соответствующий светофор (по направлению) **открыт**:
    - `sig_open = signal_is_open(...) or signal_is_shunting(...)`. 
  - Условия выполняются непрерывно не менее `TS0110`:
    - `dur_p1` накапливается;
    - при достижении порога `phase = "p1done"`;
    - при любом разрыве условий — сброс `dur_p1`, `dur_p2`, `dur_p3`. 

- Фаза 02 (ветвление 10.1 / 10.2):
  - При `phase == "p1done"` различаются две ветки: 
  - **Ветка 10.1 (движение к next = 1-7SP, `direction = "to_next"`):**
    - `prev_free`, `curr_occ`, `next_occ` (`0‑1‑1`).
    - Свой светофор (`Ч1`) выбран по направлению и **открыт** (`sig_open = True`).
    - Подряд не менее `TS0210`:
      - накапливается `dur_p2`;
      - `phase = "p2_free_prev"`. 
  - **Ветка 10.2 (движение к prev = 10-12SP, `direction = "to_prev"`):**
    - `prev_occ`, `curr_occ`, `next_free` (`1‑1‑0`). 
    - Свой светофор (`НМ1`) по направлению и **открыт**.
    - Подряд не менее `TS0210`:
      - накапливается `dur_p2`;
      - `phase = "p2_occ_prev"`.
  - При разрыве условий для текущей ветки:
    - `dur_p2` обнуляется;
    - `phase` остаётся `"p1done"`. 

- Фаза 03 (закрытие светофора, `"p2_*" → "ready"`):
  - **Для ветки 10.1 (`"p2_free_prev"`):**
    - `prev_free`, `curr_occ`, `next_occ`. 
    - Свой светофор (`Ч1`) закрыт: `sig_closed = signal_is_closed(...)`. 
    - Условия выдержаны `TS0310`:
      - накапливается `dur_p3`;
      - `phase = "ready"`, `dur_lz` обнуляется.
  - **Для ветки 10.2 (`"p2_occ_prev"`):**
    - `prev_occ`, `curr_occ`, `next_free`.
    - Свой светофор (`НМ1`) закрыт.
    - Условия выдержаны `TS0310`:
      - `phase = "ready"`, `dur_lz = 0.0`. 
  - При разрыве условий фазы 03:
    - обнуляется только `dur_p3`, ветка (`"p2_free_prev"` / `"p2_occ_prev"`) сохраняется. 

- Фаза КОГДА (LZ10, `"ready" → active`):
  - Общая для обеих веток: 
    - `prev_free`, `curr_occ`, `next_free` (`0‑1‑0`). 
    - Свой ранее зафиксированный светофор (Ч1 или НМ1) **закрыт** (`sig_closed = True`). 
    - Условия выполняются непрерывно не менее `TLZ10`:
      - открывается ЛЗ10 (`opened = True`);
      - `active = True`;
      - `dur_free_after_lz` обнуляется. 
  - При разрыве условий КОГДА:
    - сбрасывается только `dur_lz`;
    - `phase = "ready"` сохраняется. 

- Завершение ДС:
  - При `active = True`:
    - если `curr_free`:
      - накапливается `dur_free_after_lz`;
      - при `dur_free_after_lz >= TKON`:
        - ДС завершается (`closed = True`);
        - вызывается `reset()` (сброс фаз, таймеров и направления). 
    - если `curr_occ`:
      - `dur_free_after_lz` сбрасывается (контролируемая снова занята, ситуация продолжается). 
  - В активном состоянии детектор больше не выполняет фаз 01/02/03 и КОГДА, а только отслеживает освобождение по `TKON`. 
- Вариант 10 строго эталонный, логика веток, пороги и взаимодействие с `T_PK` менять нельзя.



### ЛЗ вариант 11 (`variant11_1p.py`)

- Работает по:
  - `ctrl_rc_id` — контролируемая РЦ (для участка 1П это всегда `1P`).
  - `sig_ids` — пара смежных светофоров, для которых `ctrl_rc_id` является следующей по ссылке (например, `("Ч1", "НМ1")`).
- Пороговые времена:
  - `T_S11` — фаза ДАНО (контролируемая свободна и оба светофора закрыты).
  - `T_LZ11` — фаза КОГДА (контролируемая занята и оба светофора закрыты).
  - `T_KON` — завершение ДС (свободность контролируемой РЦ).
- Формирование ДС (ДАНО):
  - Условия:
    - `ctrl_free` (контролируемая РЦ свободна).
    - оба светофора закрыты: `both_closed = signal_is_closed(st) or signal_is_shunting(st)` для каждого из двух.
  - Условия `ctrl_free & both_closed` должны выполняться непрерывно не менее `T_S11`:
    - фаза переходит из `"idle"` → `"s11_done"`;
    - накопление `dur_dano` сбрасывается при любом разрыве условий.
- Формирование ДС (КОГДА):
  - При `phase == "s11_done"`:
    - Основной сценарий (открытие ЛЗ):
      - `ctrl_occ` (контролируемая занята).
      - `both_closed`.
      - Условия выдержаны не менее `T_LZ11`:
        - ЛЗ11 открывается (`opened = True`);
        - `active = True`, `phase = "active"`;
        - `dur_free_after_lz` обнуляется.
    - Продолжение ДАНО:
      - Если `ctrl_free` и `both_closed` продолжают выполняться после достижения `T_S11`:
        - `dur_dano` продолжает накапливаться;
        - `dur_lz` сбрасывается;
        - фаза остаётся `"s11_done"`.
    - Сброс последовательности:
      - При любом другом состоянии (нет `ctrl_free`/`ctrl_occ` или светофоры не закрыты) детектор полностью сбрасывается (`reset()`).
- Завершение ДС:
  - Применяется только в фазе `"active"` при `active = True`:
    - При `ctrl_free`:
      - накапливается `dur_free_after_lz`;
      - если `dur_free_after_lz >= T_KON`:
        - ДС считается завершённым (`closed = True`);
        - вызывается `reset()`.
    - При `ctrl_occ`:
      - `dur_free_after_lz` сбрасывается (РЦ снова занята — продолжение ДС).
    - При неопределённом состоянии контролируемой РЦ:
      - `dur_free_after_lz` также сбрасывается, завершение не продвигается.
- Поведение детектора и сбросы:
  - Фазовое состояние: `"idle"` → `"s11_done"` → `"active"`.
  - В фазе `"idle"`:
    - любые нарушения `ctrl_free & both_closed` обнуляют `dur_dano` и `dur_lz`.
  - В фазе `"s11_done"`:
    - `ctrl_occ & both_closed` запускает LZ;
    - `ctrl_free & both_closed` поддерживает ДАНО;
    - любые иные комбинации приводят к полному `reset()` и возврату в `"idle"`.
  - В фазе `"active"`:
    - детектор не переходит в другие фазы, только отслеживает освобождение по `T_KON`.
- Вариант 11 строго эталонный, логика веток, пороги и взаимодействие с `T_PK` менять нельзя.

### ЛЗ вариант 12 (`variant12_1p.py`)

- Работает по трём РЦ:
  - `prev` — предыдущая РЦ.
  - `curr` — контролируемая РЦ.
  - `next` — следующая РЦ.
- Использует статусы смежности:
  - `prev_nc` (предыдущая не контролируется) и `next_nc` (следующая не контролируется) определяются из `modes["prev_control_ok"]` и `modes["next_control_ok"]` (где `*_nc = not *_control_ok`). Крайняя РЦ задаётся в ПО.
  - Логика веток меняется в зависимости от того, какая смежная РЦ считается «не контролируемой».
- Пороговые времена:
  - `T_S0112` — первая фаза (S0112).
  - `T_S0212` — вторая фаза (S0212).
  - `T_LZ12` — фаза КОГДА (LZ12).
  - `T_KON` — завершение ДС (освобождение `curr`).
- **Ветка 12.1 (предыдущая не контролируется):**
  - **Фаза 01 (S0112):**
    - Условия: `prev_nc`, `curr_occ`, `next_free`.
    - Условия выполняются подряд не менее `T_S0112` → `phase = "p1_12_1"`.
  - **Фаза 02 (S0212):**
    - Условия: `prev_nc`, `curr_occ`, `next_occ`.
    - Подряд не менее `T_S0212` → `phase = "p2_12_1"`.
  - **КОГДА (LZ12):**
    - Условия: `prev_nc`, `curr_occ`, `next_free`.
    - Подряд не менее `T_LZ12`:
      - открывается ЛЗ12 (`opened = True`);
      - `active = True`;
      - начинается отсчёт `dur_free_after_lz` для завершения.
- **Ветка 12.2 (следующая не контролируется):**
  - **Фаза 01 (S0112):**
    - Условия: `prev_free`, `curr_occ`, `next_nc`.
    - Подряд не менее `T_S0112` → `phase = "p1_12_2"`.
  - **Фаза 02 (S0212):**
    - Условия: `prev_occ`, `curr_occ`, `next_nc`.
    - Подряд не менее `T_S0212` → `phase = "p2_12_2"`.
  - **КОГДА (LZ12):**
    - Условия: `prev_free`, `curr_occ`, `next_nc`.
    - Подряд не менее `T_LZ12`:
      - открывается ЛЗ12 (`opened = True`);
      - `active = True`;
      - фиксируется начало отсчёта `dur_free_after_lz`.
- **Завершение ДС:**
  - Пока `active = True`:
    - При `curr_free`:
      - накапливается `dur_free_after_lz`;
      - если `curr_free` подряд `≥ T_KON`:
        - ДС завершается (`closed = True`);
        - вызывается `reset()`.
    - При `curr_occ`:
      - `dur_free_after_lz` сбрасывается (признак того, что ДС ещё актуальна).
    - При неопределённом состоянии `curr` (ни `free`, ни `occ`):
      - завершение не продвигается, `dur_free_after_lz` обнуляется.
- **Поведение детектора и сбросы:**
  - Фазовое состояние: `"idle"` → `"p1_12_1"/"p1_12_2"` → `"p2_12_1"/"p2_12_2"` → (LZ12) → `"active"`.
  - В фазе `"idle"`:
    - при разрыве условий S0112 обнуляются `dur_p1`, `dur_p2`, `dur_lz`.
  - В фазе `"p1_12_1"/"p1_12_2"`:
    - при разрыве условий соответствующей Фазы 1 обнуляется `dur_p1`, фаза возвращается к `"idle"`.
  - В фазе `"p2_12_1"/"p2_12_2"`:
    - при разрыве условий S0212 обнуляется `dur_p2`, фаза остаётся `"p1_*"`.
  - В фазе LZ (в контексте `"p2_12_*"`):
    - при разрыве условий КОГДА сбрасывается только `dur_lz`, фаза не откатывается.
- Вариант 12 строго эталонный, логика веток, пороги и взаимодействие с `T_PK` менять нельзя.



### ЛЗ вариант 13 (`variant13_1p.py`)

- Работает по тройке объектов:
  - `ctrl_rc` — контролируемая РЦ (10-12SP или 1-7SP).
  - `adj_rc` — смежная РЦ (для участка с 1P — всегда `1P`).
  - `signal_id` — один светофор между ними (НМ1 для 10-12SP, Ч1 для 1-7SP).
- Жёсткое требование:
  - Смежная РЦ должна быть замкнута (`adj_locked = rc_is_locked(adj_rc) = True`) на всех фазах.
  - При отсутствии замыкания накопление фаз сбрасывается.
- Пороговые времена:
  - `T_S0113` — первая фаза (S0113).
  - `T_S0213` — вторая фаза (S0213).
  - `T_LZ13` — фаза КОГДА (LZ13).
  - `T_KON` — завершение ДС (освобождение `ctrl_rc`).
- **Фаза 1 (S0113):**
  - Условия:
    - `ctrl_free` (контролируемая свободна).
    - `adj_locked` (смежная замкнута; занятость или свобода не критична).
    - `sig_closed` (светофор закрыт или маневровый закрыт через `signal_is_closed`/`signal_is_shunting`).
  - Условия выполняются непрерывно не менее `T_S0113` → переход в `phase = "p1_done"`.
- **Фаза 2 (S0213):**
  - Условия:
    - `ctrl_free`.
    - `adj_occ` и `adj_locked` (смежная занята и замкнута).
    - `sig_closed`.
  - Условия выполняются непрерывно не менее `T_S0213` → переход в `phase = "p2_done"`.
- **Фаза КОГДА (LZ13):**
  - Условия:
    - `ctrl_occ` (контролируемая занята).
    - `adj_occ` и `adj_locked`.
    - `sig_closed`.
  - Условия выполняются непрерывно не менее `T_LZ13`:
    - открывается ЛЗ13 (`opened = True`);
    - `active = True`;
    - фиксируется начало отсчёта `dur_free_after_lz` для завершения.
- **Завершение ДС:**
  - Пока `active = True`:
    - При `ctrl_free`:
      - накапливается `dur_free_after_lz`;
      - если `ctrl_free` подряд `≥ T_KON`:
        - ЛЗ13 закрывается (`closed = True`);
        - вызывается `reset()`.
    - При `ctrl_occ`:
      - `dur_free_after_lz` обнуляется (признак продолжения ДС).
    - При неопределённом состоянии `ctrl_rc` (ни `free`, ни `occ`):
      - завершение не продвигается, `dur_free_after_lz` сбрасывается.
- **Поведение детектора и сбросы:**
  - Фазовое состояние: `"idle"` → `"p1_done"` → `"p2_done"` → (LZ13) → `"active"`.
  - В фазе `"idle"`:
    - при нарушении базовых условий (`ctrl_free`, `adj_locked`, `sig_closed`) обнуляются `dur_p1`, `dur_p2`, `dur_lz`.
  - В фазе `"p1_done"`/`"p2_done"`:
    - при разрыве условий текущей фазы обнуляется только счётчик этой фазы (`dur_p2` или `dur_lz`), уже выполненные фазы не пересчитываются.
- Вариант 13 строго эталонный, логика веток, пороги и взаимодействие с `T_PK` менять нельзя.

## Варианты ЛС

### ЛС вариант 1 (`ls_variant1_1p.py`)

- Событие C0101 (формирование ЛС1):
  - Curr=1, смежные 0/NC в одной из четырёх комбинаций:
    1. Prev=0, Curr=1, Next=0;
    2. Prev=NC, Curr=1, Next=0;
    3. Prev=0, Curr=1, Next=NC;
    4. Prev=NC, Curr=1, Next=NC.
  - C0101 должно выполняться подряд `T_C0101_LS`.
  - Требуются `prev_control_ok=True`, `next_control_ok=True` (T_PK уже учтён).
- Хвост:
  - Curr=0 подряд `T_LS01`.
- Открытие ЛС1:
  - C0101 выполнено + хвост `Curr=0` по T_LS01;
  - `opened=True`, `active=True`.
- Завершение ЛС1:
  - после открытия Curr=1 суммарно `T_KON_LS` (можно с разрывами, но с накоплением);
  - `closed=True`, `reset()`.
- Потеря контроля:
  - до открытия ЛС1 — любой шаг с `*_control_ok=False` сбрасывает фазу в `idle` и обнуляет выдержки;
  - после открытия — не влияет на завершение, ЛС1 живёт по Curr/T_KON_LS.

### ЛС вариант 2 (`ls_variant2_1p.py`)

- Две ветки: «предыдущая занята» и «следующая занята».
- Фазы:
  - S0102 (первая фаза):
    - ветка prev: Prev=1, Curr=1, Next=0 `T_S0102_LS`;
    - ветка next: Prev=0, Curr=1, Next=1 `T_S0102_LS`.
  - Хвост:
    - ветка prev: Prev=1, Curr=0, Next=0, суммарное время `T ∈ [T_LS0102, T_LS0202]`;
    - ветка next: Prev=0, Curr=0, Next=1, `T ∈ [T_LS0102, T_LS0202]`.
  - S0202 (третья фаза):
    - ветка prev: Prev=1, Curr=1, Next=0 `T_S0202_LS`;
    - ветка next: Prev=0, Curr=1, Next=1 `T_S0202_LS`.
  - Открытие ЛС2 — после успешной S0102 + хвост + S0202.
- Завершение ЛС2:
  - Curr=1 суммарно `T_KON_LS2` после открытия.
- Контроль смежных:
  - до открытия:
    - если ветка выбрана (`branch="prev"` или `"next"`), контролируем только соответствующую смежную;
    - если ветка ещё не выбрана, требуется достоверен хотя бы один смежный;
  - после открытия — только Curr/T_KON_LS2.
- Вариант ЛС2 эталонный.

### ЛС вариант 4 (`ls_variant4_1p.py`)

- Фазы: `idle -> s0104 -> tail -> s0204 -> active -> closed`.
- Условие:
  - S0104: Prev=1, Curr=1, Next=1 (`1‑1‑1`) `T_S0104`;
  - Хвост: Prev=1, Curr=0, Next=1, хвост суммарно `T_LS0104 ≤ T ≤ T_LS0204`;
  - S0204: Prev=1, Curr=1, Next=1 `T_S0204`;
  - открытие ЛС4 → `active=True`.
- Завершение:
  - Curr=1 `T_KON_LS4`, `closed=True`, `ever_closed=True`.
- Особенности:
  - `ever_closed=True` блокирует повторное формирование ЛС4 до конца сценария.
  - До открытия — обязательна достоверность обеих смежных; после — только Curr/T_KON_LS4.
- Вариант ЛС4 эталонный.

## ЛС вариант 5 (`ls_variant5_1p.py`)

- Вариант 5 ЛС диагностирует **логическую ложную свободность контролируемой РЦ (curr) в связке из трёх РЦ (prev–curr–next)**, когда фактическая маска занятости соседних секций противоречит нормальной схеме движения.  
- Детектор работает строго по **топологии станции**: `prev_rc_id`, `ctrl_rc_id` и `next_rc_id` задаются при инициализации и используются для чтения `rc_states` на каждом шаге сценария; информация о достоверности смежных РЦ берётся из `ScenarioStep.modes` (`<ctrl>_prev_control_ok`, `<ctrl>_next_control_ok` или глобальные `prev_control_ok`/`next_control_ok`).  

- Параметры:  
  - `T_S0105` — минимальная длительность фазы 1 (ДАНО) по маске 1‑0‑0 или 0‑0‑1;  
  - `T_LS05` — минимальная длительность фазы 2 (КОГДА) по маске 1‑0‑1;  
  - `T_KON` — длительность непрерывной занятости curr для завершения ДС;  
  - `ever_closed` — флаг, запрещающий повторное формирование ЛС5 после первого закрытия.  

- Маски и ветки:  
  - Ветка 5.1 (предыдущая занята):  
    - фаза 1 (`cfg_p1_prev`): `prev_occ`, `curr_free`, `next_free` → маска 1‑0‑0;  
    - фаза 2 (`cfg_p2`): `prev_occ`, `curr_free`, `next_occ` → маска 1‑0‑1.  
  - Ветка 5.2 (следующая занята):  
    - фаза 1 (`cfg_p1_next`): `prev_free`, `curr_free`, `next_occ` → маска 0‑0‑1;  
    - фаза 2 — та же маска 1‑0‑1 (`cfg_p2`).  

- ДАНО и КОГДА (формирование ДС):  
  - До формирования ЛС требуется достоверность обоих смежных РЦ: `prev_control_ok` и `next_control_ok` должны быть True, иначе детектор мягко сбрасывается (`_soft_reset`) и не формирует ДС.  
  - В фазе `idle` при обнаружении `cfg_p1_prev` или `cfg_p1_next` начинается накопление `dur_p1`:  
    - если маска держится непрерывно ≥ `T_S0105`, фаза 1 считается выполненной (`p1_prev_done` / `p1_next_done`);  
    - если до этого маска нарушается — детектор сбрасывает фазу (`_soft_reset`).  
  - После завершения фазы 1 ожидается маска фазы 2 (`cfg_p2` = 1‑0‑1):  
    - при непрерывном выполнении `cfg_p2` ≥ `T_LS05` ЛС5 считается сформированным: `opened=True`, `active=True`, `phase="active"`, и начинает отсчёт времени занятости curr для завершения;  
    - если `cfg_p2` прерывается до выдержки, детектор возвращается в `idle` (`_soft_reset`).  

- Завершение ДС:  
  - В фазе `"active"` завершение зависит только от **занятости контролируемой РЦ** (curr), достоверность смежных уже не играет роли:  
    - при `curr_occ` накапливается `dur_occ_after_ls`;  
    - при `curr_free` или неопределённом состоянии `dur_occ_after_ls` обнуляется.  
  - Если `curr_occ` удерживается подряд ≥ `T_KON`:  
    - `closed=True`,  
    - `ever_closed=True`,  
    - выполняется `_soft_reset()` (фаза `"idle"`, таймеры сброшены, `active=False`).  
  - При `ever_closed_enabled=True` после первого закрытия любое последующее формирование ЛС5 запрещено до конца сценария: детектор немедленно возвращает `(False, False, False)` без смены состояний.  

***

## ЛС вариант 6 (`ls_variant6_1p.py`)

- Вариант 6 ЛС диагностирует **логическую ложную свободность контролируемой РЦ при маневровом или поездном движении через участок с одной неконтролируемой смежной РЦ**.  
- Топология prev/curr/next задаётся при инициализации детектора (`prev_rc_id`, `ctrl_rc_id`, `next_rc_id`) и опирается на *фактические* РЦ станции (как они описаны в `StationModel1P`); при этом признаки NC по смежным берутся из `ScenarioStep.modes`, которые заполняются через `compute_local_adjacency` (общая логика станции с учётом стрелок и выдержки T_PK).  
- Сигналы определяются аналогично варианту 4 ЛЗ:  
  - `signal_prev_to_ctrl_id` — светофор между prev и ctrl (поездной);  
  - `signal_ctrl_to_next_id` — светофор между ctrl и next (поездной или маневровый);  
  - `ctrl_to_next_is_shunting` задаёт тип светофора ctrl→next (маневровый или поездной) для корректной интерпретации разрешающего показания.  

- Параметры:  
  - `T_S0106` — минимальная длительность ДАНО (открытый светофор и нужная комбинация состояний prev/curr/next);  
  - `T_LS06` — минимальная длительность КОГДА (изменение занятости соседней РЦ при неизменной curr);  
  - `T_KON` — длительность непрерывной занятости контролируемой РЦ после формирования ЛС для **завершения ДС**.  

- ДАНО (фаза `"idle"`):  
  - Состояния РЦ берутся из `rc_states` по `prev_rc_id`, `ctrl_rc_id`, `next_rc_id` и разбиваются на флаги свободности/занятости/замыкания (`rc_is_free`, `rc_is_occupied`, `rc_is_locked`).  
  - Признаки неконтролируемых смежных (`prev_nc`, `next_nc`) вычисляются через `rc_no_control` по состояниям, переданным в `modes["<ctrl>_prev_state/_next_state"]` (то есть уже с учётом стрелок и T_PK).  
  - Состояния светофоров берутся из `signal_states` по `signal_prev_to_ctrl_id` и `signal_ctrl_to_next_id` и проверяются как «открытое разрешающее показание», отдельно для поездного и маневрового случая (`signal_is_open` / `signal_is_shunting` с проверкой на отсутствие закрывающего/запрещающего сигнала).  
  - Ветка 6.1 (предыдущая не контролируется):  
    - ДАНО выполняется, если:  
      - `prev_nc` (предыдущая РЦ не контролируется / край),  
      - `curr_free` и `curr_locked` (контролируемая свободна и замкнута),  
      - `next_free` и `next_locked`,  
      - `sig_prev_ctrl_open=True` (поездной сигнал prev→ctrl открыт).  
    - При непрерывном выполнении этого условия ≥ `T_S0106` переключение в фазу `"p1_6_1"`.  
  - Ветка 6.2 (следующая не контролируется):  
    - ДАНО выполняется, если:  
      - `prev_free` и `prev_locked`,  
      - `curr_free` и `curr_locked`,  
      - `next_nc` (следующая РЦ не контролируется / край),  
      - `sig_ctrl_next_open=True` (поездное или маневровое разрешение ctrl→next, в зависимости от `ctrl_to_next_is_shunting`).  
    - При выдержке ≥ `T_S0106` переключение в `"p1_6_2"`.  
  - Если ни одно из условий ДАНО не выполняется, таймеры `dur_p1`/`dur_ls` сбрасываются, фаза остаётся `"idle"`.  

- КОГДА (фазы `"p1_6_1"` и `"p1_6_2"`):  
  - Ветка 6.1 (`"p1_6_1"`):  
    - КОГДА выполняется, если:  
      - `prev_nc` сохраняется;  
      - `curr_free` и `curr_locked` (контролируемая РЦ по‑прежнему свободна и замкнута);  
      - `next_occ` и `next_locked` (соседняя РЦ стала занята и замкнута).  
    - При непрерывном выполнении этого условия ≥ `T_LS06` ЛС6 считается сформированным: `opened=True`, `active=True`, `dur_occ_after_ls=0`.  
  - Ветка 6.2 (`"p1_6_2"`):  
    - КОГДА выполняется, если:  
      - `prev_occ` и `prev_locked` (предыдущая РЦ стала занята и замкнута);  
      - `curr_free` и `curr_locked`;  
      - `next_nc` сохраняется.  
    - При выдержке ≥ `T_LS06` аналогично формируется ЛС6 (`opened=True`, `active=True`).  
  - При нарушении условий КОГДА (`cond_ls_6_1`/`cond_ls_6_2` ложны) до истечения `T_LS06` таймер `dur_ls` обнуляется, перехода в активное состояние не происходит.  

- Завершение ДС:  
  - После формирования ЛС (`active=True`) детектор больше не реагирует на сигналы и смежность для цели завершения:  
    - при `curr_occ` накапливается `dur_occ_after_ls`;  
    - при любой несоответствующей маске (в том числе при освобождении curr) `dur_occ_after_ls` сбрасывается в 0.  
  - Если `curr_occ` удерживается подряд ≥ `T_KON`:  
    - `closed=True`;  
    - `ever_closed=True` (ЛС6 больше не формируется до конца сценария);  
    - выполняется `_soft_reset()` (сброс фаз и таймеров, `active=False`).  
  - Если до выполнения `T_KON` контролируемая РЦ освобождается, счётчик завершения обнуляется, и ЛС6 остаётся активной (до повторной занятости и выдержки или конца сценария).

### ЛС вариант 9 (`ls_variant9_1p.py`)

- Для одной контролируемой РЦ `rc_id` (например, 1П).
- Фазы:
  - S0109: Curr=1 `T_S0109` (первичная занятость);
  - Хвост: Curr=0 `T ∈ [T_LS0109, T_LS0209]`;
  - S0209: Curr=1 `T_S0209`;
  - открытие ЛС9 при отсутствии исключения `is_exception(history, idx)` или при включённом тестовом режиме `test_check_ls9_active`.
- Завершение:
  - Curr=1 `T_KON` после открытия; `ever_closed=True` блокирует повторное формирование.
- Детектор работает только по Curr, без смежных; T_PK на него не влияет напрямую (только через возможные исключения).

## Флаги и взаимодействие с движком

- Все детекторы ЛЗ/ЛС интегрированы через `detectors_runner_1p.py` и `simulate_1p.py`.
- Формируются следующие флаги (см. общий README движка):
  - активность: `llz_v1`, `llz_v2`, `llz_v3`, `llz_v8`, `lls_v1`, `lls_v2`, `lls_v4`, `lls_v9`;
  - события: `*_open`, `*_closed` для каждого варианта;
  - дополнительные: `false_lz`, `no_lz_when_occupied`, `switch_lost_control_with_lz`.
- Эти имена считаются финальными; любые другие/старые флаги использовать запрещено.

