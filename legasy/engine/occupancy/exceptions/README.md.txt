# Исключения ЛЗ и ЛС

Папка содержит все исключения для логической занятости (ЛЗ) и логической ложной свободности (ЛС), а также базовые классы для их реализации. Исключения работают поверх детекторов вариантов ЛЗ/ЛС и позволяют блокировать срабатывания при специальных условиях (местное управление, недавняя ЛС/ЛЗ, манёвры под ДСП и т.п.).

Исключения **не изменяют** состояние РЦ напрямую, а только возвращают признак подавления. Решение об очистке флагов ЛЗ/ЛС и добавлении диагностических флагов принимается в `simulate_1p.py`.

## Структура

- `base.py` – базовые классы `LzException` и `LsException`.
- `exc_local_mu.py` – исключение ЛЗ по местному управлению.
- `exc_recent_ls_on_adjacent.py` – исключение ЛЗ по недавней ЛС на смежных путях.
- `exc_dsp_autoaction_timeout.py` – исключение ЛЗ при манёврах под ДСП и отключённых автодействиях.
- `exc_ls_local_mu.py` – исключение ЛС по местному управлению.
- `exc_ls_after_lz.py` – исключение ЛС после недавней ЛЗ.
- `exc_ls_dsp_autoaction.py` – исключение ЛС при ДСП и отключённых автодействиях (экспериментальное).

## Базовые классы

Файл `base.py` определяет общий интерфейс исключений.

### `LzException`

Базовый класс для исключений ЛЗ.

- Поля:
  - `id: str` – идентификатор исключения (используется во флагах `lz_suppressed:{id}`).
- Метод:
  - `should_suppress(station, history, idx, ctrl_rc_id, timeline) -> bool`  
    Вызывается для текущего шага при наличии кандидата на формирование ЛЗ по контролируемой РЦ `ctrl_rc_id`.

### `LsException`

Базовый класс для исключений ЛС.

- Поля:
  - `id: str` – идентификатор исключения (используется во флагах `ls_suppressed:{id}`).
- Метод:
  - `should_suppress(station, history, idx, ctrl_rc_id, timeline) -> bool`  
    Вызывается, когда по актуальному шагу сформирована ЛС и требуется проверить, нужно ли её подавить.

В обоих случаях:

- `station` – объект `StationModel1P` с текущим состоянием и параметрами (`t_mu`, `t_recent_ls`, `t_min_maneuver_v8`, `t_ls_mu`, `t_ls_after_lz`, `t_ls_dsp`, списки смежных РЦ, МУ, автодействий и т.п.).
- `history` – список входных шагов `ScenarioStep` с момента запуска до текущего индекса `idx`.
- `timeline` – список выходных шагов `TimelineStep`, уже сформированных до текущего момента (с флагами ЛЗ/ЛС).

## Исключения ЛЗ

### `exc_local_mu.py` — `local_mu`

Исключение ЛЗ по местному управлению.

**Идея:** если по контролируемой или смежным РЦ недавно было активно МУ, ЛЗ не должна формироваться.

- Конфигурация:
  - `LocalMuConfig.t_mu` – окно по времени (секунды), по умолчанию `15.0`.
- Параметры станции:
  - `station.t_mu` – если задано в `VariantOptions`, используется вместо значения по умолчанию.
- Логика:
  1. Определяются РЦ для контроля:
     - контролируемая РЦ `ctrl_rc_id`;
     - первая смежная «предыдущая» (`prev_candidates[0]`, если есть);
     - первая смежная «следующая» (`next_candidates[0]`, если есть).
  2. Вычисляется текущее время `t_now` как сумма `step.t` по `history[0:idx+1]`.
  3. Формируется окно `[t_now - t_mu, t_now]`, где `t_mu` берётся из `station.t_mu` либо из `LocalMuConfig.t_mu`.
  4. В этом окне история просматривается назад; если на любой из контролируемых РЦ поле `step.mu[rc_id] == 1`, исключение возвращает `True`.

**Управление:** флаг `enable_lz_exc_mu` в `VariantOptions`.

### `exc_recent_ls_on_adjacent.py` — `recent_ls_on_adjacent`

Исключение ЛЗ по недавней ЛС на смежных путях.

**Идея:** если по смежным путям недавно формировалась ЛС, новая ЛЗ по контролируемой РЦ должна подавляться.

- Конфигурация:
  - `RecentLsOnAdjacentConfig.t_recent_ls` – окно по времени, по умолчанию `12.0`.
- Параметры станции:
  - `station.t_recent_ls` – при наличии переопределяет значение по умолчанию.
- Логика:
  1. Используется `timeline` с уже записанными флагами ЛС (`lls_v*`, `lls_v*_open`, `lls_v*_closed`).
  2. Вычисляется текущее время как сумма `step_duration` по `timeline`.
  3. В окне `[t_now - t_recent_ls, t_now]` проверяется наличие флагов ЛС по смежным РЦ, связанным с `ctrl_rc_id`.
  4. При нахождении ЛС в окне исключение возвращает `True`.

**Управление:** флаг `enable_lz_exc_recent_ls` в `VariantOptions`.

### `exc_dsp_autoaction_timeout.py` — `dsp_autoaction_timeout`

Исключение ЛЗ для манёврового режима при ДСП и отключённых автодействиях.

**Идея:** при длительных манёврах под ДСП с отключёнными автодействиями ЛЗ (обычно вариант 8) не должна срабатывать, чтобы не мешать манёвровой работе.

- Конфигурация:
  - `DspAutoActionTimeoutConfig.t_min_maneuver` – минимальное время непрерывной занятости, по умолчанию `600.0` секунд.
- Параметры станции:
  - `station.t_min_maneuver_v8` – при наличии переопределяет `t_min_maneuver`.
  - `station.dispatcher_control_state` – режим управления.
  - `station.auto_actions` – список автодействий (с полями `rc_ids` и `state`).
  - `station.main_rc_ids` / `station.main_rc_by_id` – перечень главных / приёмо‑отправочных путей.
- Логика:
  1. Проверяется, что индекс `idx` валиден.
  2. Режим ДСП: `dispatcher_control_state == 4`; иначе исключение не срабатывает.
  3. По `station.auto_actions` проверяется, что для `ctrl_rc_id` есть автодействие с `state ∈ {0, 3}` (выключено).
  4. Контролируемая РЦ должна быть главным/приёмо‑отправочным путём (`main_rc_ids` или `main_rc_by_id`).
  5. Вычисляется текущий момент `t_now` и окно `[t_now - t_min_maneuver, t_now)`.
  6. В этом окне вся история `history` должна показывать непрерывную занятость `ctrl_rc_id` – состояния `rc_states[ctrl_rc_id] ∈ {6, 7, 8}`. Любое «не занято» сбрасывает условие.
  7. При выполнении всех условий возвращается `True`.

**Управление:** флаг `enable_lz_exc_dsp` в `VariantOptions`.

## Исключения ЛС

### `exc_ls_local_mu.py` — `ls_exc_mu`

Исключение ЛС по местному управлению.

**Идея:** ЛС не формируется, если по контролируемой или смежным РЦ недавно был активен МУ.

- Конфигурация:
  - `LsLocalMuConfig.t_ls_mu` – окно для МУ по ЛС.
- Параметры станции:
  - `station.t_ls_mu` – специальный таймер для ЛС;
  - при отсутствии может использоваться общий `station.t_mu`.
- Логика:
  1. Аналогична `local_mu`, но использует окно `t_ls_mu` и применяется к ЛС.
  2. Контролируются `ctrl_rc_id`, первая «предыдущая» и первая «следующая» РЦ.
  3. В окне `[t_now - t_ls_mu, t_now]` ищется состояние `mu[rc_id] == 1`.
  4. При обнаружении МУ исключение возвращает `True`.

**Управление:** флаг `enable_ls_exc_mu` в `VariantOptions`.

### `exc_ls_after_lz.py` — `ls_exc_after_lz`

Исключение ЛС после ЛЗ.

**Идея:** ЛС не должна формироваться, если по этой или смежной РЦ недавно была реальная ЛЗ.

- Конфигурация:
  - `LsAfterLzConfig.t_recent_lz` – дефолтное окно для поиска ЛЗ.
- Параметры станции:
  - `station.t_ls_after_lz` – специальный таймер для ЛС после ЛЗ;
  - при отсутствии используется `station.t_recent_ls`.
- Логика:
  1. Вычисляется текущее время по `timeline` как сумма `step_duration`.
  2. Определяется окно `[t_now - t_window, t_now]`, где `t_window` берётся из `t_ls_after_lz` или `t_recent_ls`.
  3. В этом окне таймлайна анализируются флаги ЛЗ:
     - любые флаги, начинающиеся с `llz_v` (любая ЛЗ по любому варианту).
  4. При нахождении ЛЗ в окне исключение возвращает `True`, и ЛС подавляется.

Важно: исключение опирается именно на флаги ЛЗ (`llz_v*`), а не на сырую занятость РЦ. Это предотвращает ложное подавление ЛС, когда ЛЗ ещё не формировалась.

**Управление:** флаг `enable_ls_exc_after_lz` в `VariantOptions`.

### `exc_ls_dsp_autoaction.py` — `ls_exc_dsp_autoaction` (экспериментальное)

Исключение ЛС при длительных манёврах под ДСП и отключённых автодействиях.

**Идея:** аналогично `dsp_autoaction_timeout`, но для ЛС: в условиях длительного манёвра формирование ЛС может быть нежелательным.

- Параметры станции:
  - `station.t_ls_dsp` – окно непрерывной занятости для ЛС;
  - при отсутствии используется `station.t_min_maneuver_v8`.
  - Используются также `dispatcher_control_state` и `auto_actions`, как в исключении ЛЗ.
- Логика (общее описание):
  1. Проверяется режим ДСП (`dispatcher_control_state == 4`).
  2. Для `ctrl_rc_id` существует автодействие с `state ∈ {0, 3}`.
  3. РЦ непрерывно занята в течение `t_ls_dsp` секунд (состояния `6/7/8`).
  4. При выполнении всех условий ЛС подавляется.

Статус: исключение считается экспериментальным и может быть отключено по умолчанию. Включение желательно явно согласовывать.

**Управление:** флаг `enable_ls_exc_dsp` в `VariantOptions`.

## Управление и совместимость

Все исключения управляются через флаги в `VariantOptions`:

- ЛЗ:
  - `enable_lz_exc_mu`;
  - `enable_lz_exc_recent_ls`;
  - `enable_lz_exc_dsp`.
- ЛС:
  - `enable_ls_exc_mu`;
  - `enable_ls_exc_after_lz`;
  - `enable_ls_exc_dsp`.

Правила:

- При стандартных настройках поведение должно соответствовать существующим тестам. Новые исключения и таймеры должны добавляться так, чтобы не ломать сценарии, если флаги `enable_*` не меняются.
- Любое изменение семантики уже существующих исключений (особенно временных окон и критериев занятости) выполняется только после явной проверки и согласования.
- Новые исключения рекомендуется реализовывать отдельными файлами `exc_*.py` с уникальным `id` и собственным флагом `enable_*` в `VariantOptions`.
